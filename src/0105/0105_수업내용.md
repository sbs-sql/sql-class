### 0105일 수업 

PK가 설정되어 있는 컬럼은 기본적(default)으로 NOT NULL과 ***인덱스***가 생성됨

- 인덱스(INDEX)란? 데이터베이스가 데이터를 빨리 찾을 수 있게 도와줌(SELECT할 때)
    - 데이터가 적으면 오히려 인덱스는 성능저하에 원인이 된다.
    - 인덱스는 데이터가 많은 컬럼을 조회할 때 사용해야 한다.

- 데이터베이스에서 인덱스 종류는 크게 2가지
    1. 클러스터 인덱스(Primary key 인덱스)
    2. 보조 인덱스(Unique) 단, ***MySQL***은 FK컬럼에도 INDEX를 부여한다. (오라클은 아님)
 
- 인덱스는 ***B-Tree라는 자료구조를 베이스로 실행.
- 보조인덱스는 일반 책에 목차와 같고, 클러스터 인덱스는 영어사전 처럼 정렬.
- 데이터 양이 많으면 인덱스가 좋고, 데이터 양이 적은데 인덱스를 활용하면 오히려 성능낭비.

- 전체 인덱스 조회 문법
```sql
    show index from emp
```
- 보조 인덱스 생성 문법(sal 컬럼에 보조인덱스 생성)
```sql
    create index idx_emp_sal on emp (sal)
```
- idx_emp_sal은 인덱스 변수 명
- 보조 인덱스는 여러개 만들 수 있지만, 클러스터 인덱스는 1개만 만들 수 있다.
- 인덱스를 활용하기 위해서는 서술 논리절에 인덱스를 사용해야함.
- 서술 논리절은 WHERE, ORDER BY, GROUP BY, HAVING을 의미.
- 서술 논리절에 인덱스를 활용하는 SQL문을 ***사거블(Sargable)*** 쿼리라고 함.
### 사거블 쿼리 
    서술 논리절에 인덱스를 활용하는 SQL문

- *주의할 점, 신입개발자들이 자주 실수하는 사거블 쿼리 모음
    1. LIKE 앞에 %를 붙이는 경우
    ```sql
    -- ename 컬럼에 인덱스를 부여했다고 가정
    -- LIKE '%H' 처럼 앞에 %를 사용하는 경우 인덱스 실행불가.
    select ename from emp where ename like '%H'; 
    -- 아래 쿼리는 인덱스가 실행 됨
    select ename from emp where ename like 'H%'; 
    ```

    2. WHERE절에 수치 연산을 하는 경우
    ```sql
    -- 즉, WHERE절에 인덱스 컬럼인 sal에 연산을 함. => sal * 1.10 
    select empno, ename from emp where sal * 1.10 > 3000;
    ```

    3. 한 개 이상의 필드에 대해 연산하는 함수를 사용하는 쿼리
    ```sql
    -- date_format은 한 개 이상 필드에 연산하는 함수
    select empno, ename from emp where date_format(hiredate,'%y') >= '1981'
    -- cast라는 함수를 이용해 hiredate에 직접 함수를 사용하지 않고 1981년도 이후 입사한 사원번호, 이름을 조회함.
    select empno, ename from emp where hiredate >= CAST('1981-01-01' as date)
    ```

    4. 전체 조회할 때
    ```sql
    -- 데이터베이스가 판단할 때, 인덱스가 있더라도 전체 테이블을 검색하는게 낫겠다고 판단해버림...
    select empno, ename from emp where sal >= 0;
    ```

- 인덱스는 부여했는데, 데이터베이스에서 인덱스를 활용하지 못하는 쿼리 (논 사거블 쿼리)
    1. LIKE 앞에 %가 있는 경우
    2. 사칙연산을 사용한 경우
    3. 함수를 사용한 경우
    4. 전체 조회하는 구문을 실행할 경우 

- 사거블 쿼리이지만 성능 향상 목적으로는 사용하지 않는 것
    1. IN
    2. OR
    ```sql
    -- EX) 아래 쿼리는 인덱스를 사용하지만 성능 향상 목적은 아님. why? IN을 사용했기 때문에~
    select empno, ename from emp where sal in (1250,3000)
    ```
- 사거블 쿼리이면서 성능 향상 목적!
    1. >, <, >=, <=, =
    2. BETWEEN
    3. LIKE(앞에 %를 붙이지 않을 때)
    4. IS [NOT] NULL
     ```sql
     -- ex) 아래 쿼리는 사거블 쿼리이면서 성능 향상이 된다.
    select empno, ename from emp where sal is null
     ```


- 인덱스 삭제, 삭제는 있지만 수정은 없음.
```sql
alter table emp drop index idx_emp_hiredate
```
- 인덱스를 생성하는 다른 방법
    1. create index ~~ (보조 인덱스)
    2. primary key (클러스터 인덱스)
    3. create table emp (sal int(4) unique) --> unique 뒤에 붙임, (보조 인덱스)
- 인덱스는 데이터가 많을 때 사용하며, 자주 이용하는 컬럼에 생성해주면 된다!
- 사거블 쿼리와 논 사거블 쿼리를 주의하자!
- 데이터가 없을 때 인덱스는 성능 낭비다.

### 프로시저
- 프로그래밍에서 함수와 같은 개념, 파라미터와 리턴값이 존재
- 프로시저는 DB에 저장되어 필요할 때 호출되어 실행
- 동일한 로직을 여러 번 사용할 필요가 있을 때 사용 (재사용성)
- 네트워크 비용이 감소하고 성능이 향상된다. (프로시저는 메모리에 계속 저장되어 있다~)
- 빈도 수가 적은 SQL문은 굳이 프로시저로 두면 X (대규모 프로젝트 많이 사용함,은행에서 많이 사용)
```sql
CREATE PROCEDURE study.test_proce(x integer)
begin
	select empno, sal from emp
	where sal > x;
END
-- 매개변수가 있는 프로시저 호출
call study.test_proce(2000)
-- num이 20일 때 수정 혹은 조회하는 프로시저 만들어보기
CREATE PROCEDURE study.test_proce3(num integer)
BEGIN
	if num = 20 then
		update emp set sal = sal*1.3;
	else 
		select sal, empno from emp;
	end if;
END
call study.test_proce3(20)
-- 1~10까지 더하는 프로시저 만들어보기
CREATE PROCEDURE study.test_proce4()
begin
	declare i int default 0;
	declare res int default 0;
	loop_test:loop
		if(i > 10) then
			leave loop_test;
		end if;
	set res = res + i;
	set i = i + 1;
	end loop;
	select res;
END
call study.test_proce4()
```
